---
layout: post
title: Procedural Destruction using Plane Splitting and Voronoi Noise
subtitle: Breda University of Applied Sciences Y2 Block B Project
cover-img: /assets/img/banner.png
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jpg
tags: [BUas, BuasGames]
author: Noah Modli-Gorodetsky
---

**Abstract**
-
For me, nothing brings a game more cohesion than a world that feels *tangible*. And ever since I decided to study game programming, my goal has been to learn new ways to re-create that feeling myself. It is to this end that I spent the last 8 weeks building a **Procedural Destruction System** for 3D meshes.

My goal with this blog post is to give a broad overview of how I went about destroying 3D meshes, and hopefully outline enough theory and show enough code that someone who reads this could give it a try themselves. 

**Introduction**
-
There are many different ways to go about destruction in videogames, and techniques range from prefabricating debris to deforming vertices in the GPU. For my project, I decided on procedurally creating new meshes at runtime from a 3D Voronoi diagram.

To *break down* what that means for the project, I'll basically need 3 key components.
1. **3D Voronoi Diagram Generation**
2. **Plane-Based Mesh Splitting**
3. **Debris Creation from the Modified Meshes**

New meshes, or the'debris', will ultimately be generated by taking the original mesh and repeatedly performing plane cuts to shape it into a piece of debris. The Voronoi Diagram will give me interesting shapes for the debris, and the process will be repeated for each cell in a diagram to destroy the mesh. Then I have to adapt all the relevant physics data to the debris, and the end result should be a convincing destruction.


Thankfully, I'm not starting this project with a completely blank slate. Since this project is an assignment for my study in Creative Media and Game Technologies at BUas, I'm able to use their proprietary engine to get a head start on all the boilerplate stuff, like Mesh Rendering, Physics, and an Entity Component System.

![alt text](../assets/img/buas.png)

**Voronoi Diagram Generation**
-
A Voronoi diagram is a pattern of cells generated from an assortment of points. The bounds of the cells are generated around each of the points based on the proximity of any one of the points to any other one, effectively creating edges along the bounds of equidistance between input points. The result is a collection of convex polygons of variable dimensions, and you can already see how this might lead to interesting shapes for debris.
<p align="center">
<image src="../assets/img/smolonoi.gif"></image>
</p>

[TomazTsql](https://tomaztsql.wordpress.com/2021/11/01/little-useless-useful-r-functions-interactive-voronoi-diagram-generator-using-r-and-x11/)

Adding an extra dimension to this diagram involves applying the same rules but to 3D points in a volumetric container. Of course, implementing this in code is nothing trivial, so I opted to use [Voro++](https://github.com/chr1shr/voro/tree/master), a C++ library for generating 3D voronoi diagrams. 


![alt text](../assets/img/splot.png)
<small> 3D Voronoi Diagram made using Voro++ </small>

I generate the diagram once at the beginning of the program using the library's ```voro::container```. Then, for each face of each cell, I cache a single point on the face and its normal in a plane struct to feed into my mesh splitter later.

<details>
  <summary> Container Generation & Plane Collection Code </summary>

```cpp
 int i;
 double x, y, z;
 voro::container con(min_x, max_x, min_y, max_y, min_z, max_z, n_x, n_y, n_z, false, false, false, 8);

 for (i = 0; i < NUM_CELLS; i++)
 {
     x = min_x + (double(rand()) / RAND_MAX) * (max_x - min_x);
     y = min_y + (double(rand()) / RAND_MAX) * (max_y - min_y);
     z = min_z + (double(rand()) / RAND_MAX) * (max_z - min_z);
     con.put(i, x, y, z);
 }

 con.sum_cell_volumes();

 voro::c_loop_all cla(con); 
 voro::voronoicell cell;
 if (cla.start()) do 
         if (con.compute_cell(cell, cla))
         {               
             std::vector<glm::vec3>cell_face_offsets;

             // Get all vertices of the cell
             std::vector<double> vertices;
             cell.vertices(vertices);

             // Get face information - single vector version
             std::vector<int> face_vertices;
             cell.face_vertices(face_vertices);

             // Get face normals
             std::vector<double> face_normals;
             cell.normals(face_normals); 

             std::vector<ClipPlane> cell_planes;

             // Track our position in face_vertices
             int face_start = 0;
             for (int k = 0; k < cell.number_of_faces(); k++)
             {
                 // First number in each face entry is the number of vertices in that face
                 int face_size = face_vertices[face_start];

                 // Get a vertex on the face (using the first vertex of this face)
                 int vertex_index = face_vertices[face_start + 1] * 3;  // +1 to skip the size
                 double vertex[3] = {vertices[vertex_index], vertices[vertex_index + 1], vertices[vertex_index + 2]};

                 // Get the normal for this face
                 double normal[3] = {-face_normals[k * 3], -face_normals[k * 3 + 1], -face_normals[k * 3 + 2]};

                 cell_planes.push_back(ClipPlane(ToVec3(normal), ToVec3(vertex)));

                 // Move to next face
                 face_start += face_size + 1;  // +1 for the size value itself
             }
             cell_plane_bounds.push_back(cell_planes); 
         }
     while (cla.inc());
```

</details>

<small>(Fair warning to anyone seeking to do the same, Voro++ is kind of odd and most of the documentation is for a linux-based output program, so prioritize the Github documentation over their website since its more up to date.)</small>

**
